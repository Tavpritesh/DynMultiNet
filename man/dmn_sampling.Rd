% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dmn_sampling.R
\name{dmn_sampling}
\alias{dmn_sampling}
\title{Bayesian Learning of Dynamic Multilayer Networks with binary data}
\usage{
dmn_sampling(net_data, pred_data = NULL, directed = FALSE,
  weighted = FALSE, H_dim = 10, R_dim = 10, k_x = 0.1,
  k_mu = 0.1, k_p = 0.1, a_1 = 2, a_2 = 2.5, n_chains_mcmc = 1,
  n_iter_mcmc = 1000, n_burn = n_iter_mcmc/2, n_thin = 3,
  time_fc = NULL, out_file = NULL, log_file = NULL,
  quiet_mcmc = FALSE, parallel_mcmc = FALSE)
}
\arguments{
\item{net_data}{Data frame.Network information.}

\item{pred_data}{Data frame. Linked predictors information.}

\item{directed}{Boolean. Indicates if the provided network is directed, i.e. the adjacency matrix is assymetrical.}

\item{weighted}{Boolean. Indicates if the provided network is weighted, i.e. edges with values other that 0 and 1.}

\item{H_dim}{Integer. Latent space dimension.}

\item{R_dim}{Integer. Latent space dimension, for layer specific latent vectors.}

\item{k_x}{Positive scalar. Hyperparameter controlling for the smoothness in the dynamic of latent coordinates. Smaller=smoother.}

\item{k_mu}{Positive scalar. Hyperparameter controlling for the smoothness in the dynamic of the baseline process. Smaller=smoother.}

\item{k_p}{Positive scalar. Hyperparameter controlling for the smoothness in the dynamic of the predictor coefficients. Smaller=smoother.}

\item{a_1}{Positive scalar. Hyperparameter controlling for number of effective dimensions in the latent space.}

\item{a_2}{Positive scalar. Hyperparameter controlling for number of effective dimensions in the latent space.}

\item{n_chains_mcmc}{Integer. Number of chains for the MCMC.}

\item{n_iter_mcmc}{Integer. Number of iterations for the MCMC.}

\item{n_burn}{Integer. Number of iterations discarded as part of the MCMC warming up period at the beginning of the chain.}

\item{n_thin}{Integer. Number of iterations discarded for thining the chain (reducing the autocorrelation). We keep 1 of every n_thin iterations.}

\item{time_fc}{Numeric vector. Specifies times in the networks to be forecasted.}

\item{out_file}{String. Indicates a file (.RData) where the output will be saved.}

\item{log_file}{String. Indicates a file (.txt) where the log of the process will be saved.}

\item{quiet_mcmc}{Boolean. Indicates if silent mode is preferes, if \code{FALSE} progress update is displayed.}

\item{parallel_mcmc}{Boolean. Indicates if some steps in the mcmc would be processed in parallel.}
}
\value{
A list with the following components:
\describe{
    \item{\code{theta_mcmc}}{Matrix with the chain of the parameters in the model.}
}
}
\description{
\code{dmn_sampling} Implements model from Durante and Dunson, 2018
}
\details{
The model assumes a latent variable approach
   
   \code{net_data} must be a data frame with the following columns
       \describe{
       \item{\code{source}}{Start Node}
       \item{\code{target}}{End node}
       \item{\code{weight}}{Edge weight}
       \item{\code{time}}{time associated with the edge}
       \item{\code{layer}}{Layer associated with the edge}
       }
}
\examples{

\dontrun{

set.seed(0)

synth_net <- gen_synth_net( node_all = seq(1,10),
                            time_all = seq(1,15),
                            layer_all = seq(1,3),
                            directed = FALSE,
                            H_dim = 3, R_dim = 3,
                            k_x = 0.10, k_mu = 0.10, k_p = 0.10,
                            a_1 = 1.5, a_2 = 2.5 )

set.seed(0)
net_mcmc <- dmn_sampling( net_data = synth_net$edge_data,
                          pred_data = NULL,
                          directed = FALSE,
                          H_dim = 10, R_dim = 5,
                          k_x = 0.10, k_mu = 0.10, k_p = 0.10,
                          a_1 = 2, a_2 = 2,
                          n_iter_mcmc = 2000 )
}

}
